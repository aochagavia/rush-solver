use std::fmt;

/// Represents a modification to the stage by moving a vehicle in a given direction
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub struct Move {
    pub vehicle_id: usize,
    pub direction: Direction
}

impl fmt::Display for Move {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Vehicle {} {:?}", self.vehicle_id + 1, self.direction)
    }
}

/// The direction of a vehicle's movement
///
/// By default, horizontal vehicles point to the right and vertical vehicles point down
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Direction {
    Forward,
    Backward
}

/// Represents the state of the game
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Stage {
    vehicles: Vec<Vehicle>,
    width: u32,
    height: u32
}

impl Stage {
    /// Fill the buffer with possible moves for the current stage
    pub fn available_moves(&self, move_buffer: &mut Vec<Move>) {
        // Go through each vehicle in the stage
        for vehicle_id in 0..self.vehicles.len() {

            // Attempt to move the vehicle forward or backward
            for &direction in &[Direction::Forward, Direction::Backward] {
                let move_ = Move { vehicle_id, direction };

                // Keep only valid moves
                if self.make_move(move_).is_some() {
                    move_buffer.push(move_);
                }
            }
        }
    }

    /// Return the stage generated by applying the given move, or `Nothing` if the move is invalid
    pub fn make_move(&self, move_: Move) -> Option<Stage> {
        // Preconditions:
        // * There are no overlapping vehicles
        // * Vehicle parts are completely within the bounds of the stage
        // * The direction of the movement matches the alignment of the vehicle (e.g. a vertical
        //   car moves up or down, never left or right)

        // Get the car in question
        let vehicle = &self.vehicles[move_.vehicle_id];

        // Get the square to which the car would move
        // Note: we allow underflow, because the resulting coordinates will fall out of the stage
        let dest = vehicle.destination_point(move_.direction);

        // Reject the move if the target square is out of bounds
        if dest.x >= self.width || dest.y >= self.height {
            return None;
        }

        // Reject the move if the target square is already occupied
        for vehicle in &self.vehicles {
            if vehicle.covers_point(&dest) {
                return None;
            }
        }

        // Generate and return the new stage
        let mut stage = self.clone();
        stage.vehicles[move_.vehicle_id].move_(move_.direction);
        Some(stage)
    }

    /// Return true if the player's car reaches the right side of the stage
    pub fn game_finished(&self) -> bool {
        let car = &self.vehicles[0];
        car.position.x == self.width - (car.size as u32)
    }

    /// Prints the stage in a user-friendly way
    pub fn print(&self) {
        let mut map = vec![0; self.width as usize * self.height as usize];
        for (v, vehicle) in self.vehicles.iter().enumerate() {
            let i = vehicle.position.x + vehicle.position.y * self.width;
            match vehicle.alignment {
                Alignment::Horizontal => {
                    for offset in 0..vehicle.size {
                        map[i as usize + offset as usize] = v + 1;
                    }
                }
                Alignment::Vertical => {
                    for offset in 0..vehicle.size {
                        map[i as usize + (offset as u32 * self.width) as usize] = v + 1;
                    }
                }
            }

        }

        for row in map.chunks(self.width as usize) {
            println!();
            print!("|");
            for &thing in row {
                if thing == 0 {
                    print!(" ");
                } else {
                    print!("{}", thing);
                }
            }
            print!("|");
        }

        println!()
    }

    // A sample `Stage`, taken from https://www.youtube.com/watch?v=OAlu5l3pOew
    pub fn beginner() -> Stage {
        let vehicle = |x, y, size, alignment| Vehicle { position: Point { x, y }, size, alignment};

        let vehicles = vec![
            // red_car
            vehicle(1, 2, 2, Alignment::Horizontal),
            // green_car
            vehicle(0, 0, 2, Alignment::Horizontal),
            // orange_car
            vehicle(0, 4, 2, Alignment::Vertical),
            // blue_car
            vehicle(4, 4, 2, Alignment::Horizontal),
            // purple_truck
            vehicle(0, 1, 3, Alignment::Vertical),
            // blue_truck
            vehicle(3, 1, 3, Alignment::Vertical),
            // yellow_truck
            vehicle(5, 0, 3, Alignment::Vertical),
            // green_truck
            vehicle(2, 5, 3, Alignment::Horizontal),
        ];

        Stage { vehicles, width: 6, height: 6 }
    }
}

/// Represents a vehicle on the stage
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct Vehicle {
    position: Point,
    alignment: Alignment,
    size: u8
}

impl Vehicle {
    /// Move the vehicle in the given direction
    ///
    /// Note: wrapping overflow and underflow are used
    fn move_(&mut self, direction: Direction) {
        let new_pos = match self.alignment {
            Alignment::Horizontal => {
                // Vehicle faces to the right
                match direction {
                    Direction::Forward => self.position.translate(1, 0),
                    Direction::Backward => self.position.translate(-1, 0)
                }
            }
            Alignment::Vertical => {
                // Vehicle faces down
                match direction {
                    Direction::Forward => self.position.translate(0, 1),
                    Direction::Backward => self.position.translate(0, -1)
                }
            }
        };

        self.position = new_pos;
    }

    /// Return the point that would be covered by the vehicle moving in the given direction
    fn destination_point(&self, direction: Direction) -> Point {
        match self.alignment {
            Alignment::Horizontal => {
                // Vehicle faces to the right
                match direction {
                    Direction::Forward => self.position.translate(self.size as i32, 0),
                    Direction::Backward => self.position.translate(-1, 0)
                }
            }
            Alignment::Vertical => {
                // Vehicle faces down
                match direction {
                    Direction::Forward => self.position.translate(0, self.size as i32),
                    Direction::Backward => self.position.translate(0, -1)
                }
            }
        }
    }

    /// Return true if the vehicle covers the given point
    fn covers_point(&self, point: &Point) -> bool {
        match self.alignment {
            Alignment::Horizontal => {
                self.position.y == point.y
                && (self.position.x <= point.x && point.x < self.position.x + self.size as u32)
            }
            Alignment::Vertical => {
                self.position.x == point.x
                && (self.position.y <= point.y && point.y < self.position.y + self.size as u32)
            }
        }
    }
}

/// A point in the stage
///
/// Note: point (0, 0) corresponds to the upper-left corner
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
struct Point {
    x: u32,
    y: u32
}

impl Point {
    pub fn translate(&self, x: i32, y: i32) -> Point {
        let x = (self.x as i32).wrapping_add(x) as u32;
        let y = (self.y as i32).wrapping_add(y) as u32;
        Point { x, y }
    }
}

/// The alignment of a vehicle on the stage
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub enum Alignment {
    Horizontal,
    Vertical
}

#[test]
fn test_available_moves() {
    // Create the stage
    let red_car = Vehicle {
        position: Point { x: 0, y: 2 },
        size: 2,
        alignment: Alignment::Horizontal
    };

    let truck = Vehicle {
        position: Point { x: 2, y: 0},
        size: 4,
        alignment: Alignment::Vertical
    };

    let stage = Stage {
        vehicles: vec![red_car, truck],
        width: 8,
        height: 8
    };

    // Test that everyting works properly
    let mut buf = Vec::new();
    stage.available_moves(&mut buf);
    let expected_moves = &[Move { vehicle_id: 1, direction: Direction::Forward }];
    assert_eq!(buf.as_slice(), expected_moves);
}
